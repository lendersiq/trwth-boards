<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Count Formula Demo - Social (Resilient)</title>
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NCA2NCI+PHBhdGggZmlsbD0iIzJFOEJDMCIgZD0iTTE2IDEyLjhMMzIgMEw0OCAxMi44TDQ4IDUxLjJMMzIgNjRMMTYgNTEuMloiLz48cGF0aCBmaWxsPSIjMEEyNTQwIiBkPSJNMCAwTDE2IDEyLjhMMzIgNjRMMTYgNTEuMloiLz48cGF0aCBmaWxsPSIjNThDNkIxIiBkPSJNNjQgMEw0OCAxMi44TDMyIDY0TDQ4IDUxLjJaIi8+PC9zdmc+"/>
<style>
  :root{
    --bg:#0f1216;--panel:#1a1f26;--panel-2:#161b21;--border:#2a313a;--border-soft:#222a33;
    --fg:#e8ecf1;--fg-muted:#aeb7c2;--shadow:0 8px 22px rgba(0,0,0,.35);
    --radius:12px;--gap:8px;
    --bar-pos:#1e6b9f; --bar-neg:#ff5b5b; --row-bar-color:#1e6b9f; --stripe:rgba(255,255,255,.02);
  }
  html,body{background:var(--bg);color:var(--fg);font-family:ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans";margin:0}
  .board-grid{display:grid;grid-template-columns:repeat(var(--cols,12),1fr);grid-auto-rows:var(--row-height,110px);gap:var(--gap);padding:12px}
  .board-card{display:flex;flex-direction:column;min-width:0;background:var(--panel);border:1px solid var(--border);border-radius:var(--radius);box-shadow:var(--shadow);overflow:hidden}
  .board-card__header{padding:10px 12px;font-weight:600;font-size:1.25rem;color:var(--fg);background:linear-gradient(180deg,var(--panel-2),transparent);border-bottom:1px solid var(--border-soft)}
  .board-card__body{min-height:0;overflow:auto;padding:10px 12px}

  .board-table{width:100%;border-collapse:separate;border-spacing:0}
  .board-table thead th{position:sticky;top:0;z-index:1;text-align:left;font-weight:600;color:var(--fg);
    background:linear-gradient(180deg,rgba(255,255,255,.04),rgba(255,255,255,0));border-bottom:1px solid var(--border);padding:8px 10px}
  .board-table th.num, .board-table td.num{text-align:right}

  .board-table tbody tr{background:transparent}
  .board-table tbody tr:nth-child(even):not(.row-bar){background-color:var(--stripe)}

  .board-table td{color:var(--fg);padding:8px 10px;border-bottom:1px solid var(--border-soft);white-space:nowrap;text-overflow:ellipsis;overflow:hidden;position:relative;cursor:pointer}

  .board-table td .bar-wrap{position:relative;display:block;padding:2px 0}
  .board-table td .bar-fill{position:absolute;left:0;top:50%;transform:translateY(-50%);height:70%;border-radius:6px;opacity:.25;pointer-events:none}
  .board-table td .bar-fill.pos{background:var(--bar-pos)}
  .board-table td .bar-fill.neg{background:var(--bar-neg)}
  .board-table td .bar-text{position:relative;z-index:1;display:inline-block;padding:0 .25rem;white-space:nowrap}

  .board-table tr.row-bar{
    background:
      linear-gradient(
        to right,
        var(--row-bar-color) 0%,
        var(--row-bar-color) var(--row-bar-width,0%),
        transparent var(--row-bar-width,0%)
      );
    background-size:100% 100%;
    background-repeat:no-repeat;
  }

  /* Overlapping per-user emoji badges with hover titles */
  .cell-emotions{
    position:absolute;top:2px;right:2px;display:flex;gap:0;flex-wrap:nowrap;max-width:120px;z-index:10;pointer-events:auto
  }
  .emotion-badge{
    position:relative;font-size:14px;line-height:1;padding:0 2px;margin-left:-6px;
    filter:drop-shadow(0 0 2px rgba(0,0,0,.8));cursor:default
  }
  .emotion-badge:first-child{margin-left:0}

  .emotion-popup {
    position: fixed;
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: 15px;
    box-shadow: var(--shadow);
    z-index: 1000;
    min-width: 220px;
  }

  .emotion-selector {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 8px;
    margin-bottom: 10px;
  }

  .emotion-btn {
    background: var(--panel-2);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 8px;
    cursor: pointer;
    font-size: 18px;
    text-align: center;
    transition: all 0.2s;
  }
  .emotion-btn:hover { background: var(--border); transform: scale(1.08); }
  .emotion-btn.selected { background: var(--bar-pos); border-color: var(--bar-pos); }

  .emotion-count { font-size: 12px; color: var(--fg-muted); }

  .user-status {
    position: fixed;
    top: 10px;
    right: 10px;
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: 8px 12px;
    font-size: 12px;
    color: var(--fg-muted);
    z-index: 100;
  }
  .online-indicator {
    display:inline-block;width:8px;height:8px;border-radius:50%;margin-right:5px;
  }
  .online-indicator.online { background:#66BB6A; }
  .online-indicator.offline { background:#D32F2F; }

  .email-modal {
    position: fixed; inset:0; background: rgba(0,0,0,.7);
    display:flex; align-items:center; justify-content:center; z-index:2000;
  }
  .email-modal-content {
    background: var(--panel); border: 1px solid var(--border);
    border-radius: var(--radius); padding: 22px; max-width: 420px; width: 92%;
  }
  .email-input {
    width:100%; padding:10px; margin:10px 0; background:var(--panel-2);
    border:1px solid var(--border); border-radius:6px; color:var(--fg); font-size:14px;
  }
  .btn {
    background:var(--bar-pos); color:#fff; border:none; padding:10px 16px; border-radius:6px;
    cursor:pointer; font-size:14px; transition:opacity .2s;
  }
  .btn:hover{opacity:.85}
  .btn:disabled{opacity:.5; cursor:not-allowed;}
</style>
</head>
<body>

<div class="user-status" aria-live="polite">
  <span class="online-indicator" id="onlineIndicator" title="Connectivity status"></span>
  <span id="userEmail">Loading user…</span>
</div>

<div class="board-grid" style="--cols: 12; --row-height: 110px; --gap: 8px;">
  <div class="board-card" data-block-id="commercialDemandDeposits" data-x="1" data-y="1" data-w="6" data-h="3" tabindex="0" style="grid-area: 1 / 1 / span 3 / span 6;">
    <div class="board-card__header">Commercial Demand Deposits</div>
    <div class="board-card__body">
      <section class="board-section">
        <table class="board-table">
          <thead>
            <tr>
              <th class="num">Branch</th>
              <th class="bar num" data-scale="max">Balance</th>
              <th class="num">Goal</th>
              <th class="num">Count</th>
              <th class="num">YTD Performance</th>
            </tr>
          </thead>
          <tbody>
            <tr class="row-bar" style="--row-bar-width: 49.741817231998915%;">
              <td class="num">10</td>
              <td class="num">$280,644.84</td>
              <td class="num">$200,000.00</td>
              <td class="num">2</td>
              <td class="num"><span style="color: #66BB6A;">222.69%</span></td>
            </tr>
            <tr class="row-bar" style="--row-bar-width: 100%;">
              <td class="num">2</td>
              <td class="num">$564,203.03</td>
              <td class="num">$250,000.00</td>
              <td class="num">3</td>
              <td class="num"><span style="color: #66BB6A;">358.15%</span></td>
            </tr>
            <tr class="row-bar" style="--row-bar-width: 2.556069222102547%;">
              <td class="num">4</td>
              <td class="num">$14,421.42</td>
              <td class="num">$300,000.00</td>
              <td class="num">1</td>
              <td class="num"><span style="color: #D32F2F;">7.63%</span></td>
            </tr>
          </tbody>
          <tfoot>
            <tr class="board-table__totals">
              <td style="font-weight: 700;">Total</td>
              <td class="num" style="font-weight: 600;">$859,269.29</td>
              <td class="num" style="font-weight: 600;">$750,000.00</td>
              <td class="num" style="font-weight: 600;">6</td>
              <td class="num" style="font-weight: 600;"><span style="color: #66BB6A;">181.82%</span></td>
            </tr>
          </tfoot>
        </table>
      </section>
    </div>
  </div>

  <div class="board-card" data-block-id="commercialSavingsDeposits" data-x="7" data-y="1" data-w="6" data-h="3" tabindex="0" style="grid-area: 1 / 7 / span 3 / span 6;">
    <div class="board-card__header">Commercial Savings Deposits</div>
    <div class="board-card__body">
      <section class="board-section">
        <table class="board-table">
          <thead>
            <tr>
              <th class="num">Branch</th>
              <th class="num">Balance</th>
              <th class="num">Goal</th>
              <th class="num">YTD Performance</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="num">10</td>
              <td class="num">$280,644.84</td>
              <td class="num">$150,000.00</td>
              <td class="num"><span style="color: #66BB6A;">296.91%</span></td>
            </tr>
            <tr>
              <td class="num">2</td>
              <td class="num">$1,340,956.78</td>
              <td class="num">$150,000.00</td>
              <td class="num"><span style="color: #66BB6A;">1,418.69%</span></td>
            </tr>
            <tr>
              <td class="num">4</td>
              <td class="num">$17,112.28</td>
              <td class="num">$200,000.00</td>
              <td class="num"><span style="color: #D32F2F;">13.58%</span></td>
            </tr>
          </tbody>
          <tfoot>
            <tr class="board-table__totals">
              <td style="font-weight: 700;">Total</td>
              <td class="num" style="font-weight: 600;">$1,638,713.90</td>
              <td class="num" style="font-weight: 600;">$500,000.00</td>
              <td class="num" style="font-weight: 600;"><span style="color: #66BB6A;">520.11%</span></td>
            </tr>
          </tfoot>
        </table>
      </section>
    </div>
  </div>

  <div class="board-card" data-block-id="commercialLoans" data-x="1" data-y="4" data-w="6" data-h="3" tabindex="0" style="grid-area: 4 / 1 / span 3 / span 6;">
    <div class="board-card__header">Commercial Loans closed this year</div>
    <div class="board-card__body">
      <section class="board-section">
        <table class="board-table">
          <thead>
            <tr>
              <th class="num">Officer</th>
              <th class="num">Principal</th>
              <th class="num">Goal</th>
              <th class="num">YTD Performance</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="num">92</td>
              <td class="num">$2,136,798.74</td>
              <td class="num">$219,678.80</td>
              <td class="num"><span style="color: #66BB6A;">1,543.62%</span></td>
            </tr>
          </tbody>
          <tfoot>
            <tr class="board-table__totals">
              <td style="font-weight: 700;">Total</td>
              <td class="num" style="font-weight: 600;">$2,136,798.74</td>
              <td class="num" style="font-weight: 600;">$219,678.80</td>
              <td class="num" style="font-weight: 600;"><span style="color: #66BB6A;">1,543.62%</span></td>
            </tr>
          </tfoot>
        </table>
      </section>
    </div>
  </div>

  <div class="board-card" data-block-id="uniqueLoanTypes" data-x="7" data-y="4" data-w="6" data-h="3" tabindex="0" style="grid-area: 4 / 7 / span 3 / span 6;">
    <div class="board-card__header">Unique loan type count</div>
    <div class="board-card__body">
      <section class="board-section">
        <table class="board-table">
          <thead>
            <tr>
              <th class="num">Type</th>
              <th class="num">Type Count</th>
              <th class="num">Principal</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="num">20</td>
              <td class="num">2</td>
              <td class="num">$2,136,798.74</td>
            </tr>
          </tbody>
          <tfoot>
            <tr class="board-table__totals">
              <td style="font-weight: 700;">Total</td>
              <td class="num" style="font-weight: 600;">2</td>
              <td class="num" style="font-weight: 600;">$2,136,798.74</td>
            </tr>
          </tfoot>
        </table>
      </section>
    </div>
  </div>
</div>

<script>
class SocialDashboard {
  constructor() {
    this.db = null;
    this.dbName = 'SocialDashboardDB';
    this.dbVersion = 3;
    this.userEmail = null;
    this.isOnline = navigator.onLine;
    this.emotions = ['😊', '😐', '😔', '👍', '👎', '❤️', '🔥', '💡'];
    this.currentPopup = null;
    this.syncQueue = [];
    this.initialized = false;

    this.init();
  }

  async init() {
    try {
      window.addEventListener('online',  () => this.handleOnlineStatus(true));
      window.addEventListener('offline', () => this.handleOnlineStatus(false));
      this.updateOnlineIndicator();

      await this.initDB();

      // Fire the page-load server pull immediately (non-blocking)
      const pullOnLoad = navigator.onLine ? this.syncOnLoad() : Promise.resolve();

      // Resolve user in parallel (don’t block the network pull)
      await this.checkUserEmail();

      this.setupCellInteractions();

      // Wait for the page-load pull (if still in flight), then paint IDB
      await pullOnLoad;
      await this.loadEmotionsFromTables();

      await this.logInteraction('page_visit');
      this.initialized = true;
    } catch (err) {
      console.error('[init] failed', err);
    }
  }

  /* ---------- IndexedDB ---------- */
  async initDB() {
    if (this.db) { try { this.db.close(); } catch {} this.db = null; }

    this.db = await new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.dbVersion);
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        const db = request.result;
        db.onversionchange = () => { try { db.close(); } catch {} };
        resolve(db);
      };
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        if (!db.objectStoreNames.contains('users')) {
          const userStore = db.createObjectStore('users', { keyPath: 'email' });
          userStore.createIndex('lastActive', 'lastActive');
        }
        if (!db.objectStoreNames.contains('tables')) {
          const tableStore = db.createObjectStore('tables', { keyPath: 'b' });
          tableStore.createIndex('updated', 'updated');
        }
        if (!db.objectStoreNames.contains('interactions')) {
          const interactionStore = db.createObjectStore('interactions', { keyPath: 'id', autoIncrement: true });
          interactionStore.createIndex('userEmail', 'userEmail');
          interactionStore.createIndex('timestamp', 'timestamp');
          interactionStore.createIndex('synced', 'synced');
        }
        if (db.objectStoreNames.contains('emotions')) {
          db.deleteObjectStore('emotions');
        }
      };
    });
  }

  async getStore(storeName, mode = 'readonly') {
    if (!this.db || !this.db.objectStoreNames.contains(storeName)) {
      await this.initDB();
    }
    if (!this.db.objectStoreNames.contains(storeName)) {
      throw new Error(`Store ${storeName} missing after init`);
    }
    return this.db.transaction([storeName], mode).objectStore(storeName);
  }

  /* ---------- User ---------- */
  async checkUserEmail() {
    try {
      const store = await this.getStore('users', 'readonly');
      const users = await this.getAllFromStore(store);
      if (!users || users.length === 0) {
        await this.promptForEmail();
      } else {
        const user = users.sort((a, b) => (b.lastActive || 0) - (a.lastActive || 0))[0];
        this.userEmail = user.email;
        await this.updateUserActivity();
      }
      this.updateUserDisplay();
    } catch (error) {
      console.warn('[checkUserEmail] falling back to prompt', error);
      await this.promptForEmail();
    }
  }

  async promptForEmail() {
    return new Promise((resolve) => {
      const modal = document.createElement('div');
      modal.className = 'email-modal';
      modal.innerHTML = `
        <div class="email-modal-content" role="dialog" aria-modal="true" aria-label="Enter your email">
          <h3 style="margin-top:0">Welcome to Social Dashboard</h3>
          <p>Please enter your email address to participate in social interactions:</p>
          <input type="email" class="email-input" id="emailInput" placeholder="your.email@company.com" required>
          <div style="margin-top: 12px; text-align: right; display:flex; gap:8px; justify-content:flex-end;">
            <button class="btn" id="submitEmail">Continue</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);

      const emailInput = modal.querySelector('#emailInput');
      const submitBtn = modal.querySelector('#submitEmail');

      const handleSubmit = async () => {
        const email = (emailInput.value || '').trim();
        if (this.validateEmail(email)) {
          this.userEmail = email;
          await this.saveUser(email);
          await this.updateUserActivity();
          this.updateUserDisplay();
          document.body.removeChild(modal);
          resolve();
        } else {
          alert('Please enter a valid email address');
          emailInput.focus();
        }
      };

      submitBtn.addEventListener('click', handleSubmit);
      emailInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') handleSubmit();
        if (e.key === 'Escape') { document.body.removeChild(modal); resolve(); }
      });
      emailInput.focus();
    });
  }

  validateEmail(email) { return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email); }

  async saveUser(email) {
    try {
      const store = await this.getStore('users', 'readwrite');
      await this.putInStore(store, { email, lastActive: Date.now(), createdAt: Date.now(), lastSync: 0 });
    } catch (error) { console.error('[saveUser]', error); }
  }

  async updateUserActivity() {
    if (!this.userEmail) return;
    try {
      const store = await this.getStore('users', 'readwrite');
      const user = await this.getFromStore(store, this.userEmail);
      const now = Date.now();
      if (user) { user.lastActive = now; await this.putInStore(store, user); }
      else { await this.putInStore(store, { email: this.userEmail, lastActive: now, createdAt: now, lastSync: 0 }); }
    } catch (error) { console.error('[updateUserActivity]', error); }
  }

  updateUserDisplay() {
    const el = document.getElementById('userEmail');
    el.textContent = this.userEmail || 'Guest';
  }

  /* ---------- Connectivity ---------- */
  handleOnlineStatus(online) {
    this.isOnline = online;
    this.updateOnlineIndicator();
    if (online) {
      // no periodic syncs—just flush any queued table pushes immediately
      this.flushPendingPushes().catch(err => console.warn('[flushPendingPushes]', err));
    }
  }


  updateOnlineIndicator() {
    const ind = document.getElementById('onlineIndicator');
    ind.className = `online-indicator ${this.isOnline ? 'online' : 'offline'}`;
    ind.title = this.isOnline ? 'Online' : 'Offline';
  }

  /* ---------- Cell interactions ---------- */
  setupCellInteractions() {
    document.querySelectorAll('.board-table tbody td').forEach((cell) => {
      const card = cell.closest('[data-block-id]');
      const blockId = card ? card.getAttribute('data-block-id') : '';
      const row = cell.parentElement;
      const rowIndex = Array.from(row.parentElement.children).indexOf(row);
      const colIndex = Array.from(row.children).indexOf(cell);
      const cellId = `${blockId}_${rowIndex}_${colIndex}`;
      cell.setAttribute('data-cell-id', cellId);
      cell.addEventListener('click', (e) => {
        e.stopPropagation();
        this.showEmotionPopup(cell, cellId);
      });
    });

    document.addEventListener('click', (e) => {
      if (this.currentPopup && !this.currentPopup.contains(e.target)) this.closeEmotionPopup();
    });
    document.addEventListener('keydown', (e) => { if (e.key === 'Escape') this.closeEmotionPopup(); });
  }

  showEmotionPopup(cell, cellId) {
    this.closeEmotionPopup();

    const popup = document.createElement('div');
    popup.className = 'emotion-popup';
    const rect = cell.getBoundingClientRect();
    popup.style.left = Math.min(rect.right + 10, window.innerWidth - 240) + 'px';
    popup.style.top = Math.max(rect.top, 10) + 'px';
    popup.innerHTML = `
      <div style="margin-bottom:8px;font-weight:600;">React to this cell:</div>
      <div class="emotion-selector">
        ${this.emotions.map(e => `<div class="emotion-btn" data-emotion="${e}" aria-label="React ${e}">${e}</div>`).join('')}
      </div>
      <div class="emotion-count" id="emotionCount">Loading…</div>
    `;

    popup.querySelectorAll('.emotion-btn').forEach(btn => {
      btn.addEventListener('click', async (e) => {
        e.stopPropagation();
        const emotion = btn.getAttribute('data-emotion');
        await this.addEmotion(cellId, emotion);
        this.closeEmotionPopup();
      });
    });

    document.body.appendChild(popup);
    this.currentPopup = popup;
    this.updateEmotionCount(cellId);
  }
  closeEmotionPopup() { if (this.currentPopup) { this.currentPopup.remove(); this.currentPopup = null; } }

  async pushTable(blockId) {
    const table = await this.getTableData(blockId);
    if (!table) return false;

    const payload = {
      userEmail: this.userEmail || 'guest',
      timestamp: Date.now(),
      version: '2.0',
      tables: { [blockId]: table } // ONLY this table
    };

    const CANDIDATES = [
      'https://trwth.com/social.php',
      'https://www.trwth.com/social.php'
    ];
    const API_KEY = 'TRWTH_SOCIAL_API_KEY'; // set real key or '' if disabled
    const body = JSON.stringify(payload);

    for (const base of CANDIDATES) {
      const url = API_KEY ? `${base}?k=${encodeURIComponent(API_KEY)}` : base;
      const controller = new AbortController();
      const timer = setTimeout(() => controller.abort(), 12000);
      try {
        const res = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'text/plain;charset=UTF-8' }, // no-preflight
          body,
          credentials: 'omit',
          signal: controller.signal,
          redirect: 'error'
        });
        clearTimeout(timer);
        if (!res.ok) continue;
        await res.json().catch(()=> ({}));
        return true;
      } catch {
        clearTimeout(timer);
      }
    }
    return false;
  }

  // Push ONE table, then pull emotes for that table to reconcile
  async pushTableAndPull(blockId) {
    const pushed = await this.pushTable(blockId);
    if (!pushed) return false;

    const info = await this.fetchEmotesForBlock(blockId);
    if (info && info.emotes) {
      const local = await this.getTableData(blockId);
      const merged = this.mergeEmotes(local, info.emotes);
      await this.saveTableData(blockId, merged);
      await this.updateTableEmotionDisplays(merged);
    }
    return true;
  }

  // Record a pending table push (dedupe by blockId + most recent)
  async enqueuePendingPush(blockId) {
    try {
      const store = await this.getStore('interactions', 'readwrite');
      const rec = {
        type: 'pending_push',
        userEmail: this.userEmail || 'guest',
        timestamp: Date.now(),
        data: { blockId },
        synced: false
      };
      await this.addToStore(store, rec);
    } catch (err) {
      console.warn('[enqueuePendingPush]', err);
    }
  }

  // Flush all pending pushes once we're online (event-driven)
  async flushPendingPushes() {
    try {
      const store = await this.getStore('interactions', 'readwrite');
      const all = await this.getAllFromStore(store);
      const pendings = all.filter(r => r.type === 'pending_push' && !r.synced);

      // De-dupe by blockId (keep the latest)
      const latestByBlock = new Map();
      for (const r of pendings) {
        const bid = r.data?.blockId;
        if (!bid) continue;
        const cur = latestByBlock.get(bid);
        if (!cur || r.timestamp > cur.timestamp) latestByBlock.set(bid, r);
      }

      for (const r of latestByBlock.values()) {
        const ok = await this.pushTableAndPull(r.data.blockId);
        if (ok) {
          r.synced = true;
          await this.putInStore(store, r);
        }
      }
    } catch (err) {
      console.warn('[flushPendingPushes]', err);
    }
  }

  async addEmotion(cellId, emotion) {
    try {
      const [blockId, rStr, cStr] = cellId.split('_');
      const rowIndex = parseInt(rStr, 10);
      const colIndex = parseInt(cStr, 10);

      let tableData = await this.getTableData(blockId);
      if (!tableData) tableData = this.extractTableStructure(blockId);

      if (!tableData.r[rowIndex]) tableData = this.extractTableStructure(blockId);
      if (!tableData || !tableData.r[rowIndex]) return;
      const row = tableData.r[rowIndex];
      if (!row.c[colIndex]) return;
      const targetCell = row.c[colIndex];

      // allow one reaction per user per cell (replace)
      targetCell.e = (targetCell.e || []).filter(entry => entry.u !== this.userEmail);
      targetCell.e.push({ e: emotion, u: this.userEmail || 'guest', t: Date.now() });

      await this.saveTableData(blockId, tableData);
      await this.updateCellEmotions(cellId);

      await this.logInteraction('emotion_added', { blockId, rowIndex, colIndex, emotion });

      // --- Sync ONLY the changed table (no periodic syncs) ---
      if (this.isOnline) {
        const ok = await this.pushTableAndPull(blockId);
        if (!ok) {
          // Queue it to push as soon as we're back online (event-driven, not periodic)
          await this.enqueuePendingPush(blockId);
        }
      } else {
        // offline: queue for the next online event
        await this.enqueuePendingPush(blockId);
      }

    } catch (err) { console.error('[addEmotion]', err); }
  }

  /* ---------- Table model ---------- */
  extractTableStructure(blockId) {
    const card = document.querySelector(`[data-block-id="${blockId}"]`);
    if (!card) return null;
    const table = card.querySelector('.board-table');
    if (!table) return null;

    const headers = Array.from(table.querySelectorAll('thead th')).map(th => th.textContent.trim());
    const rows = [];
    const dataRows = table.querySelectorAll('tbody tr, tfoot tr');

    dataRows.forEach((row) => {
      const cells = Array.from(row.querySelectorAll('td')).map((cell) => ({
        v: this.cleanCellValue(cell.textContent.trim()),
        e: []
      }));
      rows.push({ t: row.classList.contains('board-table__totals') ? 'total' : 'data', c: cells });
    });

    return { b: blockId, t: card.querySelector('.board-card__header')?.textContent.trim() || blockId, h: headers, r: rows, updated: Date.now() };
  }

  async getTableData(blockId) {
    try { const store = await this.getStore('tables', 'readonly'); return await this.getFromStore(store, blockId); }
    catch { return null; }
  }
  async saveTableData(blockId, tableData) {
    try { const store = await this.getStore('tables', 'readwrite'); tableData.updated = Date.now(); await this.putInStore(store, tableData); }
    catch (err) { console.error('[saveTableData]', err); }
  }

  /* ---------- Overlapping per-user badges ---------- */
  async updateCellEmotions(cellId) {
    const cell = document.querySelector(`[data-cell-id="${cellId}"]`);
    if (!cell) return;
    const existing = cell.querySelector('.cell-emotions');
    if (existing) existing.remove();

    const entries = await this.getCellEmotionsFromTables(cellId);
    if (!entries.length) return;

    entries.sort((a,b) => (a.t||0) - (b.t||0));
    const MAX = 8;
    const subset = entries.slice(-MAX);

    const container = document.createElement('div');
    container.className = 'cell-emotions';

    subset.forEach((rec, idx) => {
      const badge = document.createElement('span');
      badge.className = 'emotion-badge';
      badge.textContent = rec.e;
      const email = rec.u || 'guest';
      const when  = rec.t ? new Date(rec.t).toLocaleString() : '';
      badge.title = `${rec.e} — ${email}${when ? ` • ${when}` : ''}`;
      badge.style.zIndex = String(100 + idx);
      container.appendChild(badge);
    });

    cell.appendChild(container);
  }

  async getCellEmotionsFromTables(cellId) {
    const [blockId, rStr, cStr] = cellId.split('_');
    const rowIndex = parseInt(rStr, 10);
    const colIndex = parseInt(cStr, 10);
    const tableData = await this.getTableData(blockId);
    const row = tableData?.r?.[rowIndex];
    const cell = row?.c?.[colIndex];
    return (cell?.e) ? [...cell.e] : [];
  }

  async loadEmotionsFromTables() {
    try {
      const store = await this.getStore('tables', 'readonly');
      const tables = await this.getAllFromStore(store);
      for (const td of tables) await this.updateTableEmotionDisplays(td);
    } catch (err) { console.warn('[loadEmotionsFromTables]', err); }
  }

  async updateTableEmotionDisplays(tableData) {
    const blockId = tableData.b;
    tableData.r.forEach((row, ri) => {
      row.c.forEach((cell, ci) => {
        const cellId = `${blockId}_${ri}_${ci}`;
        if (cell.e && cell.e.length) this.updateCellEmotions(cellId);
        else {
          const cellEl = document.querySelector(`[data-cell-id="${cellId}"]`);
          if (cellEl) {
            const existing = cellEl.querySelector('.cell-emotions');
            if (existing) existing.remove();
          }
        }
      });
    });
  }

  async updateEmotionCount(cellId) {
    const el = document.getElementById('emotionCount');
    if (!el) return;
    const entries = await this.getCellEmotionsFromTables(cellId);
    if (!entries.length) { el.textContent = 'No reactions yet'; return; }
    const byEmoji = {};
    entries.forEach(({ e }) => { byEmoji[e] = (byEmoji[e] || 0) + 1; });
    el.textContent = Object.entries(byEmoji).map(([emo, n]) => `${emo} ${n}`).join(' | ');
  }

  async fetchEmotesForBlock(blockId) {
    const CANDIDATES = [
      'https://trwth.com/social.php',
      'https://www.trwth.com/social.php'
    ];
    const API_KEY = 'TRWTH_SOCIAL_API_KEY'; // set real key or '' if auth disabled

    for (const base of CANDIDATES) {
      const params = new URLSearchParams({ block: blockId, only: 'emotes' });
      if (API_KEY) params.set('k', API_KEY);
      const url = `${base}?${params}`;

      const controller = new AbortController();
      const timer = setTimeout(() => controller.abort(), 12000);
      try {
        const res = await fetch(url, { method: 'GET', credentials: 'omit', signal: controller.signal, redirect: 'error' });
        clearTimeout(timer);
        if (!res.ok) continue;
        const data = await res.json().catch(() => ({}));
        if (!data || data.block !== blockId) continue;
        return data.emotes || null; // [[{e:[...]},...], ...]
      } catch {
        clearTimeout(timer);
      }
    }
    return null;
  }

  // Update only per-cell reactions; preserve cell values
  mergeEmotes(localTable, emotesGrid /* rows: each cell like {e:[...]} */) {
    if (!localTable) return null;
    const out = { ...localTable };
    const lr = out.r || [];
    for (let ri = 0; ri < Math.max(lr.length, emotesGrid.length); ri++) {
      const row = lr[ri] || { t: 'data', c: [] };
      const erow = emotesGrid[ri] || [];
      const cols = Math.max(row.c.length, erow.length);
      const newCells = [];
      for (let ci = 0; ci < cols; ci++) {
        const cell = row.c[ci] || { v: '', e: [] };
        const eCell = erow[ci] || { e: [] };
        const byUser = new Map();
        const add = (rec) => {
          if (!rec || !rec.u) return;
          const cur = byUser.get(rec.u);
          if (!cur || (rec.t || 0) > (cur.t || 0)) byUser.set(rec.u, rec);
        };
        (cell.e || []).forEach(add);
        (eCell.e || []).forEach(add);
        const e = Array.from(byUser.values()).sort((a,b)=> (a.t||0)-(b.t||0));
        newCells.push({ v: cell.v, e });
      }
      lr[ri] = { t: row.t || 'data', c: newCells };
    }
    out.r = lr;
    out.updated = Date.now();
    return out;
  }

  // Page-load: pull emotes per table (tiny payload), merge into IDB, paint
  async syncOnLoad() {
    try {
      const blocks = this.getAllBlockIds();
      for (const blockId of blocks) {
        const emotes = await this.fetchEmotesForBlock(blockId); // GET ?block=<id>&only=emotes
        if (!emotes) continue;
        const localT = await this.getTableData(blockId) || this.extractTableStructure(blockId);
        const merged = this.mergeEmotes(localT, emotes);
        await this.saveTableData(blockId, merged);
        await this.updateTableEmotionDisplays(merged);
      }
      await this.updateLastSyncTimestamp(Date.now());
      console.log('[syncOnLoad] merged emotes for', blocks.length, 'tables');
    } catch (err) {
      console.warn('[syncOnLoad]', err);
    }
  }

  // After user changes a reaction: pull only what’s new since lastSync.
  async pullAndMerge(full = false) {
    try {
      const serverTables = await this.updateServerTables(full);
      if (!serverTables || Object.keys(serverTables).length === 0) return;

      for (const [blockId, serverT] of Object.entries(serverTables)) {
        const localT = await this.getTableData(blockId);
        const merged = this.mergeTables(localT, serverT);
        await this.saveTableData(blockId, merged);
        await this.updateTableEmotionDisplays(merged);
      }
      await this.updateLastSyncTimestamp(Date.now());
    } catch (err) {
      console.warn('[pullAndMerge]', err);
    }
  }

  // Merge server + local. Reactions are {e,u,t}; latest per user wins.
  mergeTables(localT, serverT) {
    if (!localT) return serverT;

    const out = { ...localT };
    out.t = serverT.t || localT.t;
    out.h = serverT.h || localT.h;
    out.updated = Math.max(localT.updated || 0, serverT.updated || 0);

    const lr = localT.r || [], sr = serverT.r || [];
    const maxRows = Math.max(lr.length, sr.length);
    out.r = [];

    for (let ri = 0; ri < maxRows; ri++) {
      const lrow = lr[ri] || { t: 'data', c: [] };
      const srow = sr[ri] || { t: lrow.t,   c: [] };
      const maxCols = Math.max((lrow.c||[]).length, (srow.c||[]).length);
      const row = { t: lrow.t || srow.t || 'data', c: [] };

      for (let ci = 0; ci < maxCols; ci++) {
        const lc = (lrow.c || [])[ci] || { v: '', e: [] };
        const sc = (srow.c || [])[ci] || { v: lc.v, e: [] };
        const v = sc.v ?? lc.v;

        const byUser = new Map();
        const add = (rec) => {
          if (!rec || !rec.u) return;
          const cur = byUser.get(rec.u);
          if (!cur || (rec.t || 0) > (cur.t || 0)) byUser.set(rec.u, rec);
        };
        (lc.e || []).forEach(add);
        (sc.e || []).forEach(add);

        const e = Array.from(byUser.values()).sort((a,b) => (a.t||0) - (b.t||0));
        row.c.push({ v, e });
      }
      out.r.push(row);
    }

    return out;
  }

  /* ---------- Logging & one-shot push ---------- */
  async logInteraction(type, data = {}) {
    try {
      const store = await this.getStore('interactions', 'readwrite');
      const rec = { type, userEmail: this.userEmail || 'guest', timestamp: Date.now(), data, synced: false };
      const id = await this.addToStore(store, rec);
      this.syncQueue.push({ type: 'interaction', data: { ...rec, id } });
    } catch (err) { console.error('[logInteraction]', err); }
  }

  async markItemsAsSynced() {
    try {
      const store = await this.getStore('interactions', 'readwrite');
      for (const item of this.syncQueue) {
        if (item.type === 'interaction') {
          const existing = await this.getFromStore(store, item.data.id);
          if (existing) { existing.synced = true; await this.putInStore(store, existing); }
        }
      }
    } catch (err) { console.error('[markItemsAsSynced]', err); }
  }

  async updateLastSyncTimestamp(ts) {
    try {
      const store = await this.getStore('users', 'readwrite');
      const user = await this.getFromStore(store, this.userEmail);
      if (user) { user.lastSync = ts || Date.now(); await this.putInStore(store, user); }
    } catch (err) { console.error('[updateLastSyncTimestamp]', err); }
  }
  async getLastSyncTimestamp() {
    try { const store = await this.getStore('users', 'readonly'); const user = await this.getFromStore(store, this.userEmail); return user?.lastSync || 0; }
    catch { return 0; }
  }

  /* ---------- Utilities & server I/O ---------- */
  cleanCellValue(v) { return (v || '').replace(/\s+/g, ' ').trim(); }

  // POST snapshot (text/plain to avoid preflight)
  async updateServerSync(payload) {
    const CANDIDATES = [
      'https://trwth.com/social.php',
      'https://www.trwth.com/social.php'
    ];
    const API_KEY = ''; // set to your real key or leave blank if auth disabled
    const body = JSON.stringify(payload);

    for (const base of CANDIDATES) {
      const url = API_KEY ? `${base}?k=${encodeURIComponent(API_KEY)}` : base;
      const controller = new AbortController();
      const timer = setTimeout(() => controller.abort(), 12000);
      try {
        const res = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'text/plain;charset=UTF-8' },
          body,
          credentials: 'omit',
          signal: controller.signal,
          redirect: 'error'
        });
        clearTimeout(timer);
        if (!res.ok) continue;
        await res.json().catch(() => ({}));
        return true;
      } catch { clearTimeout(timer); }
    }
    return false;
  }

  // GET tables; when full==true, ignore watermark for complete snapshot
  async updateServerTables(full = false) {
    const CANDIDATES = [
      'https://trwth.com/social.php',
      'https://www.trwth.com/social.php'
    ];
    const API_KEY = ''; // set to your real key or leave blank if auth disabled

    let since = 0;
    if (!full) {
      try { since = await this.getLastSyncTimestamp(); } catch {}
    }

    for (const base of CANDIDATES) {
      const params = new URLSearchParams();
      if (API_KEY) params.set('k', API_KEY);
      if (!full && since) params.set('since', String(since));
      const url = params.toString() ? `${base}?${params}` : base;

      const controller = new AbortController();
      const timer = setTimeout(() => controller.abort(), 12000);
      try {
        const res = await fetch(url, { method: 'GET', credentials: 'omit', signal: controller.signal, redirect: 'error' });
        clearTimeout(timer);
        if (!res.ok) continue;
        const { tables = {}, serverTime } = await res.json().catch(() => ({}));
        if (serverTime) { try { await this.updateLastSyncTimestamp(serverTime); } catch {} }
        return tables || {};
      } catch { clearTimeout(timer); }
    }
    return {};
  }

  // IDB helpers
  async getFromStore(store, key) {
    return new Promise((resolve, reject) => { const req = store.get(key); req.onsuccess = () => resolve(req.result); req.onerror = () => reject(req.error); });
  }
  async putInStore(store, data) {
    return new Promise((resolve, reject) => { const req = store.put(data); req.onsuccess = () => resolve(req.result); req.onerror = () => reject(req.error); });
  }
  async addToStore(store, data) {
    return new Promise((resolve, reject) => { const req = store.add(data); req.onsuccess = () => resolve(req.result); req.onerror = () => reject(req.error); });
  }
  async getAllFromStore(store) {
    return new Promise((resolve, reject) => { const req = store.getAll(); req.onsuccess = () => resolve(req.result || []); req.onerror = () => reject(req.error); });
  }
  getAllBlockIds() {
  return Array.from(document.querySelectorAll('[data-block-id]'))
    .map(el => el.getAttribute('data-block-id'))
    .filter(Boolean);
}

}

document.addEventListener('DOMContentLoaded', () => { new SocialDashboard(); });
</script>

</body>
</html>
